#!/usr/bin/env python

## Copyright 2024 EPFL
## Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
## SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1

# type " python gen_stimuly.py " in the terminal to generate the matrices.h file

import sys
import random
import numpy as np

def write_arr(file_name, name, arr, ctype):

    f = open(file_name, 'w')
    f.write('// This file is automatically generated\n')

    f.write('#ifndef ' + name.upper() + '_H_\n')
    f.write('#define ' + name.upper() + '_H_\n')

    f.write('#include <stdint.h>\n')

    f.write('#define ' + name.upper() + '_SIZE_ ' + str(np.prod(arr.shape)) + '\n')

    f.write(" " + ctype + " " + name + "[] = {\n")

    for elem in arr[:-1]:
        f.write('%d,' % (elem))
    f.write('%d,\n' % (arr[-1]))

    f.write('};\n\n')

    f.write('#endif //' + name.upper() + '_H_\n')

    f.close()
    return


class WeightMatrix:
    def __init__(self, name, id, rows, cols, RANGE=10):
        self.rows = rows
        self.cols = cols
        self.name = name
        self.id   = id
        self.mean = 1
        self.scale = 3
        np.random.seed(42)
        self.matrix = np.random.randint(0, RANGE, size=(rows, cols), dtype=np.int8)
        #self.bias = np.random.randint(0, RANGE, size=(rows, 1), dtype=np.int8) 
        self.bias = np.zeros((rows, 1), dtype=np.int8)

    def printf_header_file(self):

        ctype = "int8_t"
        file_name = self.name + '.h'

        f = open(file_name, 'w')
        f.write('// This file is automatically generated\n')

        f.write('#ifndef ' + self.name.upper() + '_H_\n')
        f.write('#define ' + self.name.upper() + '_H_\n')

        f.write('#include <stdint.h>\n')

        f.write('#define ' + self.name.upper() + '_ROW_ ' + str(self.rows) + '\n')
        f.write('#define ' + self.name.upper() + '_COL_ ' + str(self.cols) + '\n')

        f.write('#define ' + self.name.upper() + '_SIZE_ ' + str(self.rows*self.cols) + '\n')

        f.write(" " + ctype + " __attribute__((section(\".xheep_data_interleaved\"))) " + self.name + "_w[] = {\n")

        for row in self.matrix:
            for value in row[:-1]:
                f.write('%d,' % (value))
            f.write('%d,\n' % (row[-1]))

        f.write('};\n\n')

        f.write('#define ' + self.name.upper() + '_BIAS_SIZE_ ' + str(np.prod(self.bias.shape)) + '\n')

        f.write(" int32_t __attribute__((section(\".xheep_data_interleaved\"))) " + self.name + "_b[] = {\n")

        for value in self.bias[:-1]:
            f.write('%d,' % (value))
        f.write('%d,\n' % (self.bias[-1]))

        f.write('};\n\n')

        f.write(" int32_t __attribute__((section(\".xheep_data_interleaved\"))) " + self.name + "_mean = " + str(self.mean)+ ";\n")
        f.write(" int32_t __attribute__((section(\".xheep_data_interleaved\"))) " + self.name + "_scale = " + str(self.scale)+ ";\n")

        f.write('#endif //' + self.name.upper() + '_H_\n')
        f.close()
    
        return


class Layer:
    def __init__(self, id, weights, input):
        self.id = id
        self.input = input
        self.name = 'output_layer_' + str(id)
        self.matmul = np.matmul(weights.matrix.astype(np.int32),input.astype(np.int32)) + weights.bias.astype(np.int32)
        self.batchnorm = (self.matmul - weights.mean)/weights.scale
        #self.output_reg = np.right_shift(self.output, 20).astype(np.int8)
        self.batchnorm_reg = self.batchnorm.astype(np.int8)
        self.relu = np.maximum(0, self.batchnorm_reg)
        self.output = self.matmul.astype(np.int8)

    def printf_header_file(self):

        file_name = self.name + '.h'

        f = open(file_name, 'w')
        f.write('// This file is automatically generated\n')

        f.write('#ifndef ' + self.name.upper() + '_H_\n')
        f.write('#define ' + self.name.upper() + '_H_\n')
        f.write('#include <stdint.h>\n')


        f.write('#define INPUT_LAYER_' + str(id) + '_SIZE_ ' + str(np.prod(self.input.shape)) + '\n')
        f.write('#define ' + self.name.upper() + '_SIZE_ ' + str(np.prod(self.output.shape)) + '\n')

        #f.write(" int8_t " + self.name + "[] = {\n")
        f.write(" int8_t __attribute__((section(\".xheep_data_interleaved\"))) " + self.name + "[] = {\n")

        for value in self.output[:-1]:
            f.write('%d,' % (value))
        f.write('%d,\n' % (self.output[-1]))

        f.write('};\n\n')

        f.write('#endif //' + self.name.upper() + '_H_\n')
        f.close()

# this example is based on the anomaly detection app 
# available at https://github.com/mlcommons/tiny/tree/master/benchmark/training/anomaly_detection

DATA_RANGE_MIN = 0
DATA_RANGE_MAX = 10

INPUT_SIZE = 640

#INPUT_SIZE = 6

np.random.seed(42)
nn_input = np.random.randint(DATA_RANGE_MIN, DATA_RANGE_MAX, size=(INPUT_SIZE, 1), dtype=np.int8) 

write_arr("input_signal.h", "input_signal", nn_input, "int8_t")

# Generate random 8 bit integers for the weights (they should be the ones of the trained model)
# Define matrix dimensions
W1_ROW = 128
W1_COL = INPUT_SIZE
W2_ROW = 128
W2_COL = 128
W3_ROW = 128
W3_COL = 128
W4_ROW = 128
W4_COL = 128
W5_ROW = 8
W5_COL = 128
W6_ROW = 128
W6_COL = 8
W7_ROW = 128
W7_COL = 128
W8_ROW = 128
W8_COL = 128
W9_ROW = 128
W9_COL = 128
W10_ROW = 640
W10_COL = 128

# W1_ROW = 16
# W1_COL = INPUT_SIZE
# W2_ROW = 16
# W2_COL = 16
# W3_ROW = 16
# W3_COL = 16
# W4_ROW = 16
# W4_COL = 16
# W5_ROW = 2
# W5_COL = 16
# W6_ROW = 16
# W6_COL = 2
# W7_ROW = 16
# W7_COL = 16
# W8_ROW = 16
# W8_COL = 16
# W9_ROW = 16
# W9_COL = 16
# W10_ROW = 6
# W10_COL = 16

# Create instances of the WeightMatrix class
W0 = WeightMatrix('weight0', 0, W1_ROW, W1_COL)
W1 = WeightMatrix('weight1', 1, W2_ROW, W2_COL)
W2 = WeightMatrix('weight2', 2, W3_ROW, W3_COL)
W3 = WeightMatrix('weight3', 3, W4_ROW, W4_COL)
W4 = WeightMatrix('weight4', 4, W5_ROW, W5_COL)
W5 = WeightMatrix('weight5', 5, W6_ROW, W6_COL)
W6 = WeightMatrix('weight6', 6, W7_ROW, W7_COL)
W7 = WeightMatrix('weight7', 7, W8_ROW, W8_COL)
W8 = WeightMatrix('weight8', 8, W9_ROW, W9_COL)
W9 = WeightMatrix('weight9', 9, W10_ROW, W10_COL)

weight_matrices = [W0, W1, W2, W3, W4, W5, W6, W7, W8, W9]

intermediate_outputs = []

intermediate_intput = nn_input

id = 0

for W in weight_matrices:
    O = Layer(id, W, intermediate_intput)
    intermediate_outputs.append(O)

    print("Layer " + str(id)) 

    print("input")
    print(np.prod(intermediate_intput.shape))
    print(intermediate_intput)

    print("W")
    print(np.prod(W.matrix.shape)/1024)
    print(W.matrix)

    print("output")
    print(O.output)

    print("\n\n\n")

    W.printf_header_file()
    O.printf_header_file()

    intermediate_intput = O.output


    id+=1

